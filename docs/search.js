window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "gistools.utils", "modulename": "gistools.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "gistools.utils.has_method", "modulename": "gistools.utils", "qualname": "has_method", "kind": "function", "doc": "<p>Checks if an object has a callable method with the given name.</p>\n\n<p>Args:\n        arg: The object to check for the method.\n        method: The name of the method to look for.</p>\n\n<p>Returns:\n        True if the object has a method with the given name that is also callable (a function), False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg</span>, </span><span class=\"param\"><span class=\"n\">method</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.get_class_name", "modulename": "gistools.utils", "qualname": "get_class_name", "kind": "function", "doc": "<p>Retrieves the class name of the given object.</p>\n\n<p>This function takes an object of any type as input and returns the name\nof the class to which it belongs. This can be useful for introspection\nor debugging purposes, where you might need to determine the type\nof an object at runtime.</p>\n\n<p>Args:\n        obj (object): The object whose class name you want to obtain.</p>\n\n<p>Returns:\n        str: The name of the class to which the object belongs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.get_class_attr", "modulename": "gistools.utils", "qualname": "get_class_attr", "kind": "function", "doc": "<p>Retrieves public attributes of a given class.</p>\n\n<p>This function takes the name of a class (<code>classname</code>) as input and returns\na list of its public attributes (excluding methods and dunder methods).\nIt uses <code>inspect.getmembers</code> to introspect the class and filters out\nmethods using <code>inspect.isroutine</code> and dunder methods (those starting and\nending with double underscores) using list comprehension.</p>\n\n<p>Args:\n        classname (str): The name of the class to introspect.</p>\n\n<p>Returns:\n        list: A list of public attributes (strings) of the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">classname</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.isoformat_as_datetime", "modulename": "gistools.utils", "qualname": "isoformat_as_datetime", "kind": "function", "doc": "<p>Converts an ISO 8601 formatted string to a datetime object.</p>\n\n<p>Args:\n        s: The ISO 8601 formatted string to convert.\n        format_string: The format string to use for parsing. Defaults to '%Y-%m-%dT%H:%M:%SZ'.</p>\n\n<p>Returns:\n        A datetime object representing the parsed date and time.</p>\n\n<p>Example:\n        isoformat_as_datetime('2023-10-26T12:34:56Z') \n        # Output: datetime.datetime(2023, 10, 26, 12, 34, 56)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;%Y-%m-</span><span class=\"si\">%d</span><span class=\"s1\">T%H:%M:%SZ&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.str2datetime", "modulename": "gistools.utils", "qualname": "str2datetime", "kind": "function", "doc": "<p>Converts a string representing a date and time to a datetime object.</p>\n\n<p>Args:\n        s: The string representing the date and time.\n        format_string: The format string to use for parsing. Defaults to '%d/%m/%Y %H:%M:%S'.</p>\n\n<p>Returns:\n        A datetime object representing the parsed date and time.</p>\n\n<p>Example:\n        str2datetime('26/10/2023 12:34:56') \n        # Output: datetime.datetime(2023, 10, 26, 12, 34, 56)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%d</span><span class=\"s1\">/%m/%Y %H:%M:%S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.datetime2str", "modulename": "gistools.utils", "qualname": "datetime2str", "kind": "function", "doc": "<p>Converts a datetime object to a string representation.</p>\n\n<p>Args:\n        d: The datetime object to convert.\n        format_string: The format string to use for the conversion. Defaults to '%d/%m/%Y %H:%M:%S'.</p>\n\n<p>Returns:\n        A string representation of the datetime object in the specified format.</p>\n\n<p>Example:\n        datetime2str(datetime(2023, 10, 26, 12, 34, 56)) \n        # Output: '26/10/2023 12:34:56'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%d</span><span class=\"s1\">/%m/%Y %H:%M:%S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.str2localdatetime", "modulename": "gistools.utils", "qualname": "str2localdatetime", "kind": "function", "doc": "<p>Converts a UTC datetime string to a local datetime object.</p>\n\n<p>Args:\n        s: The string representing the UTC datetime.\n        format_string: The format string to use for parsing. Defaults to '%Y-%m-%dT%H:%M:%S.000Z'.\n        timezone: The timezone to convert to. Defaults to 'Europe/Paris'.</p>\n\n<p>Returns:\n        A local datetime object representing the parsed date and time in the specified timezone.</p>\n\n<p>Example:\n        str2localdatetime('2023-10-26T12:34:56.000Z', timezone='Europe/London') \n        # Output: datetime.datetime(2023, 10, 26, 13, 34, 56, tzinfo=<DstTzInfo 'Europe/London' LMT+0:00:00 STD>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;%Y-%m-</span><span class=\"si\">%d</span><span class=\"s1\">T%H:%M:%S.000Z&#39;</span>, </span><span class=\"param\"><span class=\"n\">timezone</span><span class=\"o\">=</span><span class=\"s1\">&#39;Europe/Paris&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.str2timestamp", "modulename": "gistools.utils", "qualname": "str2timestamp", "kind": "function", "doc": "<p>Converts a string representing a date and time to a Unix timestamp (integer seconds since epoch).</p>\n\n<p>Args:\n        s: The string representing the date and time.\n        format_string: The format string to use for parsing. Defaults to '%d/%m/%Y %H:%M:%S'.</p>\n\n<p>Returns:\n        An integer representing the Unix timestamp.</p>\n\n<p>Example:\n        str2timestamp('26/10/2023 12:34:56') \n        # Output: 1703720496</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%d</span><span class=\"s1\">/%m/%Y %H:%M:%S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.utc_to_local", "modulename": "gistools.utils", "qualname": "utc_to_local", "kind": "function", "doc": "<p>Converts a UTC datetime object to a local datetime object.</p>\n\n<p>Args:\n        utc_dt: The UTC datetime object to convert.</p>\n\n<p>Returns:\n        A local datetime object representing the same date and time in the local timezone.</p>\n\n<p>Example:\n        utc_dt = datetime(2023, 10, 26, 12, 34, 56, tzinfo=timezone.utc)\n        local_dt = utc_to_local(utc_dt)\n        # Output: datetime.datetime(2023, 10, 26, 14, 34, 56) (assuming local time is UTC+2)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">utc_dt</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.str2localtimestamp", "modulename": "gistools.utils", "qualname": "str2localtimestamp", "kind": "function", "doc": "<p>Converts a UTC datetime string to a local timestamp (integer seconds since epoch).</p>\n\n<p>Args:\n        s: The string representing the UTC datetime.\n        format_string: The format string to use for parsing. Defaults to '%Y-%m-%dT%H:%M:%S.%fZ'.</p>\n\n<p>Returns:\n        An integer representing the local timestamp.</p>\n\n<p>Example:\n        str2localtimestamp('2023-10-26T12:34:56.000Z') \n        # Output: 1703724096 (assuming local time is UTC+2)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;%Y-%m-</span><span class=\"si\">%d</span><span class=\"s1\">T%H:%M:%S.</span><span class=\"si\">%f</span><span class=\"s1\">Z&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.timestamp2str", "modulename": "gistools.utils", "qualname": "timestamp2str", "kind": "function", "doc": "<p>Converts a Unix timestamp (integer seconds since epoch) to a string representation.</p>\n\n<p>Args:\n        t: The Unix timestamp (integer).\n        format_string: The format string to use for the conversion. Defaults to '%d/%m/%Y %H:%M:%S'.</p>\n\n<p>Returns:\n        A string representation of the timestamp in the specified format.</p>\n\n<p>Example:\n        timestamp2str(1703720496) \n        # Output: '26/10/2023 12:34:56'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%d</span><span class=\"s1\">/%m/%Y %H:%M:%S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.timestr2seconds", "modulename": "gistools.utils", "qualname": "timestr2seconds", "kind": "function", "doc": "<p>Converts a time string in HH:MM:SS format to seconds.</p>\n\n<p>Args:\n        timestr: The time string in HH:MM:SS format.</p>\n\n<p>Returns:\n        The time in seconds.</p>\n\n<p>Example:\n        timestr2seconds(\"01:02:03\")\n        # Output: 3723</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">timestr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.timestr2minutes", "modulename": "gistools.utils", "qualname": "timestr2minutes", "kind": "function", "doc": "<p>Converts a time string in MM:SS format to minutes.</p>\n\n<p>Args:\n        timestr: The time string in MM:SS format.</p>\n\n<p>Returns:\n        The time in minutes.</p>\n\n<p>Example:\n        timestr2minutes(\"02:03\")\n        # Output: 2.05</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">timestr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.seconds2timestr", "modulename": "gistools.utils", "qualname": "seconds2timestr", "kind": "function", "doc": "<p>Converts a duration in seconds to a time string in the specified format.</p>\n\n<p>Args:\n        duration: The duration in seconds.\n        format_string: The format string to use for the conversion. Defaults to '%H:%M:%S'.</p>\n\n<p>Returns:\n        A time string representing the duration in the specified format.</p>\n\n<p>Example:\n        seconds2timestr(3723) \n        # Output: '01:02:03'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">duration</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;%H:%M:%S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.to_timestr", "modulename": "gistools.utils", "qualname": "to_timestr", "kind": "function", "doc": "<p>Converts a duration in seconds to a time string in HH:MM:SS format.</p>\n\n<p>Args:\n        seconds: The duration in seconds.</p>\n\n<p>Returns:\n        A time string representing the duration in HH:MM:SS format.</p>\n\n<p>Example:\n        to_timestr(3723) \n        # Output: '01:02:03'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">seconds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.total_seconds", "modulename": "gistools.utils", "qualname": "total_seconds", "kind": "function", "doc": "<p>Calculates the total number of seconds between two datetime strings.</p>\n\n<p>Args:\n        start: The starting datetime string.\n        end: The ending datetime string.\n        format_string: The format string to use for parsing the datetime strings. Defaults to '%d/%m/%Y %H:%M:%S'.</p>\n\n<p>Returns:\n        The total number of seconds between the two datetime strings.</p>\n\n<p>Example:\n        total_seconds('26/10/2023 12:34:56', '27/10/2023 14:56:00') \n        # Output: 91204.0</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start</span>, </span><span class=\"param\"><span class=\"n\">end</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%d</span><span class=\"s1\">/%m/%Y %H:%M:%S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.format_datetime", "modulename": "gistools.utils", "qualname": "format_datetime", "kind": "function", "doc": "<p>Converts a datetime string from one format to another.</p>\n\n<p>Args:\n        s: The datetime string to convert.\n        format_from: The format string of the input datetime string. Defaults to '%d/%m/%Y %H:%M:%S'.\n        format_to: The format string of the output datetime string. Defaults to '%Y-%m-%dT%H:%M:%SZ'.</p>\n\n<p>Returns:\n        The datetime string in the specified output format.</p>\n\n<p>Example:\n        format_datetime('26/10/2023 12:34:56', format_to='%d-%m-%YT%H:%M:%SZ') \n        # Output: '26-10-2023T12:34:56Z'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">format_from</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%d</span><span class=\"s1\">/%m/%Y %H:%M:%S&#39;</span>, </span><span class=\"param\"><span class=\"n\">format_to</span><span class=\"o\">=</span><span class=\"s1\">&#39;%Y-%m-</span><span class=\"si\">%d</span><span class=\"s1\">T%H:%M:%SZ&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_date", "modulename": "gistools.utils", "qualname": "is_date", "kind": "function", "doc": "<p>Checks if a string represents a valid date in the specified format.</p>\n\n<p>Args:\n        d: The string to check.\n        format_string: The format string to use for parsing the date. Defaults to '%d/%m/%Y'.</p>\n\n<p>Returns:\n        True if the string represents a valid date, False otherwise.</p>\n\n<p>Example:\n        is_date('26/10/2023')  # True\n        is_date('26/10/2023 12:34:56')  # False (because it includes time)\n        is_date('2023-10-26', format_string='%Y-%m-%d')  # True</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%d</span><span class=\"s1\">/%m/%Y&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_time", "modulename": "gistools.utils", "qualname": "is_time", "kind": "function", "doc": "<p>Checks if a string represents a valid time in the specified format.</p>\n\n<p>Args:\n        t: The string to check.\n        format_string: The format string to use for parsing the time. Defaults to '%H:%M:%S'.</p>\n\n<p>Returns:\n        True if the string represents a valid time, False otherwise.</p>\n\n<p>Example:\n        is_time('12:34:56') # True\n        is_time('12:34:56 AM') # False (because it includes AM/PM)\n        is_time('12:34:56.123') # True (allows milliseconds)\n        is_time('12:34') # False (missing seconds)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;%H:%M:%S&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.isocalendar", "modulename": "gistools.utils", "qualname": "isocalendar", "kind": "function", "doc": "<p>Returns the ISO calendar tuple (ISO year, ISO week number, ISO weekday) for a given date string.</p>\n\n<p>Args:\n        s: The date string to convert.\n        format_string: The format string to use for parsing the date. Defaults to '%d/%m/%Y'.</p>\n\n<p>Returns:\n        A tuple containing (ISO year, ISO week number, ISO weekday).</p>\n\n<p>Example:\n        isocalendar('26/10/2023') \n        # Output: (2023, 43, 3)  # Wednesday of the 43rd week in 2023</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%d</span><span class=\"s1\">/%m/%Y&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.weekday", "modulename": "gistools.utils", "qualname": "weekday", "kind": "function", "doc": "<p>Returns the weekday (1-7) for a given date string, where 1 is Monday and 7 is Sunday.</p>\n\n<p>Args:\n        s: The date string to convert.\n        format_string: The format string to use for parsing the date. Defaults to '%d/%m/%Y'.</p>\n\n<p>Returns:\n        The weekday (1-7).</p>\n\n<p>Example:\n        weekday('26/10/2023') \n        # Output: 3  # Wednesday</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%d</span><span class=\"s1\">/%m/%Y&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.weekday_name", "modulename": "gistools.utils", "qualname": "weekday_name", "kind": "function", "doc": "<p>Returns the full name of the weekday for a given date string.</p>\n\n<p>Args:\n        s: The date string to convert.\n        format_string: The format string to use for parsing the date. Defaults to '%d/%m/%Y'.</p>\n\n<p>Returns:\n        The full name of the weekday (e.g., \"Monday\", \"Tuesday\", ...).</p>\n\n<p>Example:\n        weekday_name('26/10/2023') \n        # Output: 'Wednesday'</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span>, </span><span class=\"param\"><span class=\"n\">format_string</span><span class=\"o\">=</span><span class=\"s1\">&#39;</span><span class=\"si\">%d</span><span class=\"s1\">/%m/%Y&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.isnan", "modulename": "gistools.utils", "qualname": "isnan", "kind": "function", "doc": "<p>Checks if a number is NaN (Not a Number). </p>\n\n<p>Args:\n        number: The number to check.</p>\n\n<p>Returns:\n        True if the number is NaN, False otherwise.</p>\n\n<p>Example:\n        isnan(float('nan'))  # True\n        isnan(1.0)         # False\n        isnan(None)        # False (None is not a number)</p>\n\n<p>Important Note: \n        While this approach works for checking NaN in Python, it's worth noting that \n        math.isnan is a dedicated function provided by the math module for this purpose. \n        It's recommended to use math.isnan for more explicit and robust NaN checks.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">number</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_numeric", "modulename": "gistools.utils", "qualname": "is_numeric", "kind": "function", "doc": "<p>Checks if a given string represents a numeric value.\nCredits: <a href=\"http://www.rosettacode.org/wiki/Determine_if_a_string_is_numeric#Python\">http://www.rosettacode.org/wiki/Determine_if_a_string_is_numeric#Python</a></p>\n\n<p>Args:\n        literal: The string to check.</p>\n\n<p>Returns:\n        True if the string represents a numeric value, False otherwise.</p>\n\n<p>Example:\n        is_numeric(\"123\")     # True (integer)\n        is_numeric(\"12.34\")   # True (float)\n        is_numeric(\"1.23e+5\") # True (scientific notation)\n        is_numeric(\"0x1A\")    # True (hexadecimal)\n        is_numeric(\"0b101\")   # True (binary)\n        is_numeric(\"0o123\")   # True (octal)\n        is_numeric(\"abc\")     # False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">literal</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_integer", "modulename": "gistools.utils", "qualname": "is_integer", "kind": "function", "doc": "<p>Checks if a number is an integer.</p>\n\n<p>Args:\n        number: The number to check.</p>\n\n<p>Returns:\n        True if the number is an integer, False otherwise.</p>\n\n<p>Example:\n        is_integer(10)   # True\n        is_integer(10.5) # False\n        is_integer(\"10\") # False (string)\n        is_integer(10.0) # True (float with no decimal part)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">number</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_numeric_and_integer", "modulename": "gistools.utils", "qualname": "is_numeric_and_integer", "kind": "function", "doc": "<p>Checks if a given argument is both numeric and an integer.</p>\n\n<p>Args:\n        arg: The argument to check.</p>\n\n<p>Returns:\n        True if the argument is both numeric and an integer, False otherwise.</p>\n\n<p>Example:\n        is_numeric_and_integer(\"123\")  # True\n        is_numeric_and_integer(\"12.3\") # False (numeric but not an integer)\n        is_numeric_and_integer(\"abc\")  # False (not numeric)\n        is_numeric_and_integer(123)    # True\n        is_numeric_and_integer(12.3)   # False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_float", "modulename": "gistools.utils", "qualname": "is_float", "kind": "function", "doc": "<p>Checks if a number is a float (floating-point number).</p>\n\n<p>Args:\n        number: The number to check.</p>\n\n<p>Returns:\n        True if the number is a float, False otherwise.</p>\n\n<p>Example:\n        is_float(10.5)     # True\n        is_float(10)       # True (integer can be represented as a float)\n        is_float(\"10.5\")   # False (string)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">number</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_number_regex", "modulename": "gistools.utils", "qualname": "is_number_regex", "kind": "function", "doc": "<p>Checks if a string represents a numeric value using regular expressions.</p>\n\n<p>Args:\n        s: The string to check.</p>\n\n<p>Returns:\n        True if the string represents a numeric value, False otherwise.</p>\n\n<p>Example:\n        is_number_regex(\"123\")      # True (integer)\n        is_number_regex(\"12.34\")    # True (float)\n        is_number_regex(\"1.23e+5\")  # False (scientific notation not handled)\n        is_number_regex(\"0x1A\")     # False (hexadecimal not handled)\n        is_number_regex(\"0b101\")    # False (binary not handled)\n        is_number_regex(\"0o123\")    # False (octal not handled)\n        is_number_regex(\"abc\")      # False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_number_repl_isdigit", "modulename": "gistools.utils", "qualname": "is_number_repl_isdigit", "kind": "function", "doc": "<p>Checks if a string represents a numeric value using string manipulation.</p>\n\n<p>Args:\n        s: The string to check.</p>\n\n<p>Returns:\n        True if the string represents a numeric value, False otherwise.</p>\n\n<p>Example:\n        is_number_repl_isdigit(\"123\")   # True (integer)\n        is_number_repl_isdigit(\"12.34\") # True (float)\n        is_number_regex(\"1.23e+5\")      # False (scientific notation not handled)\n        is_number_regex(\"0x1A\")         # False (hexadecimal not handled)\n        is_number_regex(\"0b101\")        # False (binary not handled)\n        is_number_regex(\"0o123\")        # False (octal not handled)\n        is_number_regex(\"abc\")          # False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.to_int", "modulename": "gistools.utils", "qualname": "to_int", "kind": "function", "doc": "<p>Attempts to convert a given element to an integer. </p>\n\n<p>Args:\n        element: The element to convert.</p>\n\n<p>Returns:\n        The integer representation of the element if successful, otherwise NaN.</p>\n\n<p>Example:\n        to_int(\"123\")  # 123\n        to_int(\"12.3\") # NaN\n        to_int(\"abc\")  # NaN\n        to_int(123)    # 123</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">element</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.format_float", "modulename": "gistools.utils", "qualname": "format_float", "kind": "function", "doc": "<p>Formats a float value to remove trailing zeros and the decimal point if unnecessary,\nallowing for customization of the number of decimal places.</p>\n\n<p>Args:\n        arg: The float value to format.\n        decimals: The number of decimal places to display. Defaults to 2.</p>\n\n<p>Returns:\n        The formatted string representation of the float.</p>\n\n<p>Example:\n        format_float(12.3456) # \"12.35\"\n        format_float(12.0) # \"12\"\n        format_float(12.000) # \"12\"\n        format_float(12.3456, decimals=3) # \"12.346\"\n        format_float(12.3456, decimals=0) # \"12\"</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg</span>, </span><span class=\"param\"><span class=\"n\">decimals</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_list", "modulename": "gistools.utils", "qualname": "is_list", "kind": "function", "doc": "<p>Checks if an object is a list-like structure.</p>\n\n<p>Args:\n        arg: The object to check.</p>\n\n<p>Returns:\n        True if the object is a list-like structure, False otherwise.</p>\n\n<p>Notes:\n        - This function checks for both <code>__getitem__</code> (for indexing) and <code>__iter__</code> (for iteration)\n          to cover various list-like objects, including custom classes.\n        - It excludes dictionaries (<code>dict</code>) and strings (<code>str</code>).</p>\n\n<p>Credits:\n        <a href=\"https://github.com/googlemaps/google-maps-services-python/blob/master/googlemaps/convert.py\">https://github.com/googlemaps/google-maps-services-python/blob/master/googlemaps/convert.py</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_array", "modulename": "gistools.utils", "qualname": "is_array", "kind": "function", "doc": "<p>Checks if an object is array-like (has a length attribute).</p>\n\n<p>Args:\n        a: The object to check.</p>\n\n<p>Returns:\n        True if the object is array-like, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_in_collection", "modulename": "gistools.utils", "qualname": "is_in_collection", "kind": "function", "doc": "<p>Checks if an element is present in a collection.</p>\n\n<p>Args:\n        element: The element to search for.\n        collection: An iterable object (list, tuple, set, etc.) to search in.</p>\n\n<p>Returns:\n        True if the element is found in the collection, False otherwise.</p>\n\n<p>Example:\n        is_in_collection(3, [1, 2, 3, 4])  # True\n        is_in_collection('a', {'a', 'b', 'c'})  # True\n        is_in_collection(5, [1, 2, 3, 4])  # False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">element</span>, </span><span class=\"param\"><span class=\"n\">collection</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">iter</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.remove_none", "modulename": "gistools.utils", "qualname": "remove_none", "kind": "function", "doc": "<p>Removes None values from a list.</p>\n\n<p>Args:\n        l: The list to remove None values from.</p>\n\n<p>Returns:\n        A new list with all None values removed.</p>\n\n<p>Example:\n        remove_none([1, None, 2, None, 3]) # Output: [1, 2, 3]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.intersection", "modulename": "gistools.utils", "qualname": "intersection", "kind": "function", "doc": "<p>Returns the intersection of two lists (elements present in both lists).</p>\n\n<p>Args:\n        list1_: The first list.\n        list2_: The second list.</p>\n\n<p>Returns:\n        A new list containing the elements present in both input lists.</p>\n\n<p>Example:\n        intersection([1, 2, 3, 4], [3, 4, 5, 6]) # Output: [3, 4]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list1_</span>, </span><span class=\"param\"><span class=\"n\">list2_</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.itemgetter", "modulename": "gistools.utils", "qualname": "itemgetter", "kind": "function", "doc": "<p>Gets a specific item from each element in a list of dictionaries.</p>\n\n<p>Args:\n        l: The list of dictionaries.\n        key: The key to extract from each dictionary.</p>\n\n<p>Returns:\n        A new list containing the values for the specified key from each dictionary.</p>\n\n<p>Example:\n        itemgetter([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}], 'a') # Output: [1, 3]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_in_list", "modulename": "gistools.utils", "qualname": "is_in_list", "kind": "function", "doc": "<p>Checks if all elements in a list are present in another list or pattern.</p>\n\n<p>Args:\n        l: The list to check.\n        pattern: The list or pattern to check against.</p>\n\n<p>Returns:\n        True if all elements in <code>l</code> are found in <code>pattern</code>, False otherwise.</p>\n\n<p>Example:\n        is_in_list([1, 2, 3], [1, 2, 3, 4, 5])  # True\n        is_in_list([1, 2, 3], [1, 2, 4, 5])  # False\n        is_in_list(['a', 'b', 'c'], 'abcdefg')  # True (pattern can be a string)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">pattern</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_in_list_of_dict", "modulename": "gistools.utils", "qualname": "is_in_list_of_dict", "kind": "function", "doc": "<p>Checks if a specific value exists for a given key in any dictionary within a list of dictionaries.</p>\n\n<p>Args:\n        l: The list of dictionaries.\n        key: The key to search for.\n        value: The value to search for.</p>\n\n<p>Returns:\n        True if the value is found for the specified key in any dictionary, False otherwise.</p>\n\n<p>Example:\n        is_in_list_of_dict([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}], 'a', 3) # True\n        is_in_list_of_dict([{'a': 1, 'b': 2}, {'a': 3, 'b': 4}], 'a', 5) # False</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.drop_duplicates", "modulename": "gistools.utils", "qualname": "drop_duplicates", "kind": "function", "doc": "<p>Removes duplicate elements from a list while preserving order.</p>\n\n<p>Args:\n        l: The list to remove duplicates from.</p>\n\n<p>Returns:\n        A new list with duplicate elements removed, preserving the order of the remaining elements.</p>\n\n<p>Example:\n        drop_duplicates([1, 2, 2, 3, 1, 4]) # Output: [1, 2, 3, 4]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.subfinder", "modulename": "gistools.utils", "qualname": "subfinder", "kind": "function", "doc": "<p>Finds elements in a list that are present in another list or pattern.</p>\n\n<p>Args:\n        l: The list to search in.\n        pattern: The list or pattern to match against.</p>\n\n<p>Returns:\n        A new list containing elements from <code>l</code> that are also present in <code>pattern</code>.</p>\n\n<p>Example:\n        subfinder([1, 2, 3, 4, 5], [2, 4, 6]) # Output: [2, 4]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">pattern</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.split_listoftuples", "modulename": "gistools.utils", "qualname": "split_listoftuples", "kind": "function", "doc": "<p>Splits a list of tuples into separate lists based on their elements.</p>\n\n<p>Args:\n        l: The list of tuples to split.</p>\n\n<p>Returns:\n        A new list containing separate lists for each element in the original tuples.</p>\n\n<p>Example:\n        split_listoftuples([(1, 2), (3, 4), (5, 6)]) # Output: [[1, 3, 5], [2, 4, 6]]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.find_duplicates", "modulename": "gistools.utils", "qualname": "find_duplicates", "kind": "function", "doc": "<p>Finds duplicate elements in a list.</p>\n\n<p>Args:\n        l: The list to search for duplicates.</p>\n\n<p>Returns:\n        A new list containing only the duplicate elements.</p>\n\n<p>Example:\n        find_duplicates([1, 2, 2, 3, 1, 4]) # Output: [1, 2]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.add_to", "modulename": "gistools.utils", "qualname": "add_to", "kind": "function", "doc": "<p>Adds a value to each element in a list.</p>\n\n<p>Args:\n        l: The list to modify.\n        value: The value to add to each element.</p>\n\n<p>Returns:\n        A new list with the value added to each element.</p>\n\n<p>Example:\n        add_to([1, 2, 3], 5) # Output: [6, 7, 8]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">l</span>, </span><span class=\"param\"><span class=\"n\">value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.merge_dicts", "modulename": "gistools.utils", "qualname": "merge_dicts", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dict1</span>, </span><span class=\"param\"><span class=\"n\">dict2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.none_dict", "modulename": "gistools.utils", "qualname": "none_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">from_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_empty", "modulename": "gistools.utils", "qualname": "is_empty", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">usecols</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_set", "modulename": "gistools.utils", "qualname": "is_set", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">record</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_set_toint", "modulename": "gistools.utils", "qualname": "is_set_toint", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">record</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_set_tofloat", "modulename": "gistools.utils", "qualname": "is_set_tofloat", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">record</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_set_tostr", "modulename": "gistools.utils", "qualname": "is_set_tostr", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">record</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_dataframe", "modulename": "gistools.utils", "qualname": "is_dataframe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">records</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.get_dataframe", "modulename": "gistools.utils", "qualname": "get_dataframe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.get_columns", "modulename": "gistools.utils", "qualname": "get_columns", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">empty</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.from_dict", "modulename": "gistools.utils", "qualname": "from_dict", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>, </span><span class=\"param\"><span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.where", "modulename": "gistools.utils", "qualname": "where", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">expr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.isin", "modulename": "gistools.utils", "qualname": "isin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.not_isin", "modulename": "gistools.utils", "qualname": "not_isin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.join", "modulename": "gistools.utils", "qualname": "join", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">left</span>, </span><span class=\"param\"><span class=\"n\">right</span>, </span><span class=\"param\"><span class=\"n\">left_on</span>, </span><span class=\"param\"><span class=\"n\">right_on</span>, </span><span class=\"param\"><span class=\"n\">how</span><span class=\"o\">=</span><span class=\"s1\">&#39;left&#39;</span>, </span><span class=\"param\"><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.to_geo", "modulename": "gistools.utils", "qualname": "to_geo", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">from_</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">&#39;longitude&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;latitude&#39;</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">epsg</span><span class=\"o\">=</span><span class=\"mi\">4326</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geopandas</span><span class=\"o\">.</span><span class=\"n\">geodataframe</span><span class=\"o\">.</span><span class=\"n\">GeoDataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.select", "modulename": "gistools.utils", "qualname": "select", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">enum</span>, </span><span class=\"param\"><span class=\"n\">on</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.ospathextension", "modulename": "gistools.utils", "qualname": "ospathextension", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.ospathfilename", "modulename": "gistools.utils", "qualname": "ospathfilename", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.ospathjoin", "modulename": "gistools.utils", "qualname": "ospathjoin", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pathname</span>, </span><span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.make_directory", "modulename": "gistools.utils", "qualname": "make_directory", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"n\">folder</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_tsp_file", "modulename": "gistools.utils", "qualname": "is_tsp_file", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_vrp_file", "modulename": "gistools.utils", "qualname": "is_vrp_file", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_csv_file", "modulename": "gistools.utils", "qualname": "is_csv_file", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.is_json", "modulename": "gistools.utils", "qualname": "is_json", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.read_dataframe", "modulename": "gistools.utils", "qualname": "read_dataframe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">filename</span>,</span><span class=\"param\">\t<span class=\"n\">pathname</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">encoding</span><span class=\"o\">=</span><span class=\"s1\">&#39;utf-8&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"s1\">&#39;;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">decode</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">index</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.to_dataframe", "modulename": "gistools.utils", "qualname": "to_dataframe", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataframe</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span>,</span><span class=\"param\">\t<span class=\"n\">pathname</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">encoding</span><span class=\"o\">=</span><span class=\"s1\">&#39;utf-8&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"s1\">&#39;;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">with_index</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">usecols</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.read_pickle", "modulename": "gistools.utils", "qualname": "read_pickle", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">pathname</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">from_</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.to_pickle", "modulename": "gistools.utils", "qualname": "to_pickle", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">obj</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">pathname</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.read_json", "modulename": "gistools.utils", "qualname": "read_json", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">pathname</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.to_json", "modulename": "gistools.utils", "qualname": "to_json", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">json_dict</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">pathname</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">indent</span><span class=\"o\">=</span><span class=\"mi\">4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.read_csv", "modulename": "gistools.utils", "qualname": "read_csv", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">pathname</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"s1\">&#39;;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "gistools.utils.to_csv", "modulename": "gistools.utils", "qualname": "to_csv", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span>,</span><span class=\"param\">\t<span class=\"n\">pathname</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">encoding</span><span class=\"o\">=</span><span class=\"s1\">&#39;utf-8&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"s1\">&#39;;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">with_index</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">usecols</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();